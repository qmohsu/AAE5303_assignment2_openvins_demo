#!/usr/bin/env python3
"""
OpenVINS Trajectory Evaluation Script
=====================================

This script evaluates Visual-Inertial Odometry (VIO) trajectories generated by OpenVINS.
It computes standard trajectory evaluation metrics including:
- Absolute Trajectory Error (ATE)
- Relative Pose Error (RPE)
- Drift analysis
- Trajectory statistics

Author: AAE5303 Assignment 2
Date: December 2024
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec
import pandas as pd
from scipy.spatial.transform import Rotation
from scipy.interpolate import interp1d
import argparse
import os
import sys
from typing import Tuple, Optional, Dict, List
import yaml


class TrajectoryEvaluator:
    """
    A comprehensive trajectory evaluator for VIO systems like OpenVINS.
    """
    
    def __init__(self, est_file: str, gt_file: Optional[str] = None):
        """
        Initialize the evaluator with trajectory files.
        
        Args:
            est_file: Path to estimated trajectory file (TUM format)
            gt_file: Path to ground truth trajectory file (TUM format), optional
        """
        self.est_trajectory = self._load_trajectory(est_file)
        self.gt_trajectory = self._load_trajectory(gt_file) if gt_file else None
        self.aligned_est = None
        self.aligned_gt = None
        self.metrics = {}
        
    def _load_trajectory(self, filepath: str) -> np.ndarray:
        """
        Load trajectory from TUM format file.
        
        TUM format: timestamp tx ty tz qx qy qz qw
        
        Args:
            filepath: Path to trajectory file
            
        Returns:
            numpy array of shape (N, 8) with columns [t, x, y, z, qx, qy, qz, qw]
        """
        if not os.path.exists(filepath):
            raise FileNotFoundError(f"Trajectory file not found: {filepath}")
            
        data = np.loadtxt(filepath)
        if data.ndim == 1:
            data = data.reshape(1, -1)
            
        if data.shape[1] != 8:
            raise ValueError(f"Expected 8 columns (TUM format), got {data.shape[1]}")
            
        # Sort by timestamp
        data = data[data[:, 0].argsort()]
        
        print(f"Loaded trajectory with {len(data)} poses from {filepath}")
        return data
    
    def align_trajectories(self, method: str = 'se3') -> Tuple[np.ndarray, np.ndarray]:
        """
        Align estimated trajectory to ground truth using Umeyama alignment.
        
        Args:
            method: Alignment method - 'se3' (rotation + translation) or 
                   'sim3' (rotation + translation + scale)
                   
        Returns:
            Tuple of aligned (estimated, ground_truth) trajectories
        """
        if self.gt_trajectory is None:
            print("No ground truth available, skipping alignment")
            self.aligned_est = self.est_trajectory.copy()
            return self.aligned_est, None
            
        # Interpolate to common timestamps
        est_interp, gt_interp = self._interpolate_trajectories()
        
        # Extract positions
        est_pos = est_interp[:, 1:4]
        gt_pos = gt_interp[:, 1:4]
        
        # Compute alignment using Umeyama method
        if method == 'sim3':
            R, t, s = self._umeyama_alignment(est_pos, gt_pos, with_scale=True)
        else:  # se3
            R, t, s = self._umeyama_alignment(est_pos, gt_pos, with_scale=False)
            
        # Apply transformation
        aligned_pos = s * (R @ est_pos.T).T + t
        
        # Create aligned trajectory
        self.aligned_est = est_interp.copy()
        self.aligned_est[:, 1:4] = aligned_pos
        self.aligned_gt = gt_interp.copy()
        
        print(f"Alignment: scale={s:.6f}, translation={np.linalg.norm(t):.4f}m")
        
        return self.aligned_est, self.aligned_gt
    
    def _interpolate_trajectories(self) -> Tuple[np.ndarray, np.ndarray]:
        """Interpolate trajectories to common timestamps."""
        est_times = self.est_trajectory[:, 0]
        gt_times = self.gt_trajectory[:, 0]
        
        # Find overlapping time range
        t_start = max(est_times[0], gt_times[0])
        t_end = min(est_times[-1], gt_times[-1])
        
        # Use estimated timestamps within overlap
        mask = (est_times >= t_start) & (est_times <= t_end)
        common_times = est_times[mask]
        
        if len(common_times) < 3:
            raise ValueError("Insufficient overlapping timestamps for alignment")
        
        # Interpolate ground truth to estimated timestamps
        gt_interp = np.zeros((len(common_times), 8))
        gt_interp[:, 0] = common_times
        
        for i in range(1, 8):
            f = interp1d(gt_times, self.gt_trajectory[:, i], 
                        kind='linear', fill_value='extrapolate')
            gt_interp[:, i] = f(common_times)
            
        est_interp = self.est_trajectory[mask]
        
        return est_interp, gt_interp
    
    def _umeyama_alignment(self, src: np.ndarray, dst: np.ndarray, 
                          with_scale: bool = False) -> Tuple[np.ndarray, np.ndarray, float]:
        """
        Compute optimal alignment using Umeyama method.
        
        Args:
            src: Source points (N, 3)
            dst: Destination points (N, 3)
            with_scale: Whether to estimate scale
            
        Returns:
            Rotation matrix R, translation t, scale s
        """
        # Centroids
        src_mean = src.mean(axis=0)
        dst_mean = dst.mean(axis=0)
        
        # Centered coordinates
        src_centered = src - src_mean
        dst_centered = dst - dst_mean
        
        # Covariance matrix
        H = src_centered.T @ dst_centered / len(src)
        
        # SVD
        U, S, Vt = np.linalg.svd(H)
        
        # Rotation
        R = Vt.T @ U.T
        
        # Handle reflection
        if np.linalg.det(R) < 0:
            Vt[-1, :] *= -1
            R = Vt.T @ U.T
            
        # Scale
        if with_scale:
            src_var = np.sum(src_centered ** 2) / len(src)
            s = np.sum(S) / src_var
        else:
            s = 1.0
            
        # Translation
        t = dst_mean - s * R @ src_mean
        
        return R, t, s
    
    def compute_ate(self) -> Dict[str, float]:
        """
        Compute Absolute Trajectory Error (ATE).
        
        Returns:
            Dictionary with ATE statistics
        """
        if self.aligned_est is None:
            self.align_trajectories()
            
        if self.aligned_gt is None:
            # Self-consistency check without ground truth
            return self._compute_trajectory_stats()
            
        # Position errors
        pos_errors = np.linalg.norm(
            self.aligned_est[:, 1:4] - self.aligned_gt[:, 1:4], axis=1
        )
        
        ate_stats = {
            'ate_rmse': np.sqrt(np.mean(pos_errors ** 2)),
            'ate_mean': np.mean(pos_errors),
            'ate_median': np.median(pos_errors),
            'ate_std': np.std(pos_errors),
            'ate_min': np.min(pos_errors),
            'ate_max': np.max(pos_errors)
        }
        
        self.metrics.update(ate_stats)
        return ate_stats
    
    def compute_rpe(self, delta: float = 1.0, delta_unit: str = 'seconds') -> Dict[str, float]:
        """
        Compute Relative Pose Error (RPE).
        
        Args:
            delta: The time/frame delta for relative comparisons
            delta_unit: 'seconds' or 'frames'
            
        Returns:
            Dictionary with RPE statistics
        """
        if self.aligned_est is None:
            self.align_trajectories()
            
        trajectory = self.aligned_est
        timestamps = trajectory[:, 0]
        positions = trajectory[:, 1:4]
        
        trans_errors = []
        rot_errors = []
        
        for i in range(len(trajectory) - 1):
            if delta_unit == 'seconds':
                # Find index at delta seconds later
                target_time = timestamps[i] + delta
                j = np.searchsorted(timestamps, target_time)
                if j >= len(trajectory):
                    continue
            else:
                j = i + int(delta)
                if j >= len(trajectory):
                    continue
                    
            # Relative translation
            rel_trans = positions[j] - positions[i]
            trans_errors.append(np.linalg.norm(rel_trans))
            
            # Relative rotation (quaternion)
            q_i = trajectory[i, 4:8]
            q_j = trajectory[j, 4:8]
            
            # Compute relative rotation angle
            r_i = Rotation.from_quat(q_i)
            r_j = Rotation.from_quat(q_j)
            rel_rot = r_i.inv() * r_j
            rot_angle = np.abs(rel_rot.magnitude())
            rot_errors.append(np.degrees(rot_angle))
            
        trans_errors = np.array(trans_errors)
        rot_errors = np.array(rot_errors)
        
        rpe_stats = {
            'rpe_trans_rmse': np.sqrt(np.mean(trans_errors ** 2)),
            'rpe_trans_mean': np.mean(trans_errors),
            'rpe_trans_std': np.std(trans_errors),
            'rpe_rot_rmse': np.sqrt(np.mean(rot_errors ** 2)),
            'rpe_rot_mean': np.mean(rot_errors),
            'rpe_rot_std': np.std(rot_errors)
        }
        
        self.metrics.update(rpe_stats)
        return rpe_stats
    
    def _compute_trajectory_stats(self) -> Dict[str, float]:
        """Compute trajectory statistics when no ground truth is available."""
        positions = self.est_trajectory[:, 1:4]
        timestamps = self.est_trajectory[:, 0]
        
        # Total distance traveled
        distances = np.linalg.norm(np.diff(positions, axis=0), axis=1)
        total_distance = np.sum(distances)
        
        # Duration
        duration = timestamps[-1] - timestamps[0]
        
        # Average velocity
        avg_velocity = total_distance / duration if duration > 0 else 0
        
        # Bounding box
        bbox_min = positions.min(axis=0)
        bbox_max = positions.max(axis=0)
        bbox_size = bbox_max - bbox_min
        
        stats = {
            'total_distance': total_distance,
            'duration': duration,
            'avg_velocity': avg_velocity,
            'num_poses': len(positions),
            'bbox_x': bbox_size[0],
            'bbox_y': bbox_size[1],
            'bbox_z': bbox_size[2],
            'start_position': positions[0].tolist(),
            'end_position': positions[-1].tolist()
        }
        
        self.metrics.update(stats)
        return stats
    
    def compute_drift(self) -> Dict[str, float]:
        """
        Compute trajectory drift metrics.
        
        Returns:
            Dictionary with drift statistics
        """
        positions = self.est_trajectory[:, 1:4]
        timestamps = self.est_trajectory[:, 0]
        
        # Total distance
        distances = np.linalg.norm(np.diff(positions, axis=0), axis=1)
        total_distance = np.sum(distances)
        
        # Start-to-end drift (if loop closure expected)
        end_to_start = np.linalg.norm(positions[-1] - positions[0])
        
        # Drift per meter
        drift_per_meter = end_to_start / total_distance if total_distance > 0 else 0
        
        # Height drift
        height_drift = positions[-1, 2] - positions[0, 2]
        
        drift_stats = {
            'drift_total': end_to_start,
            'drift_per_meter': drift_per_meter * 100,  # percentage
            'drift_x': positions[-1, 0] - positions[0, 0],
            'drift_y': positions[-1, 1] - positions[0, 1],
            'drift_z': height_drift,
            'total_distance': total_distance
        }
        
        self.metrics.update(drift_stats)
        return drift_stats
    
    def analyze_velocity(self) -> Dict[str, float]:
        """
        Analyze velocity profile of the trajectory.
        
        Returns:
            Dictionary with velocity statistics
        """
        positions = self.est_trajectory[:, 1:4]
        timestamps = self.est_trajectory[:, 0]
        
        # Compute velocities
        dt = np.diff(timestamps)
        dp = np.diff(positions, axis=0)
        
        # Avoid division by zero
        dt[dt < 1e-6] = 1e-6
        
        velocities = np.linalg.norm(dp, axis=1) / dt
        
        vel_stats = {
            'vel_mean': np.mean(velocities),
            'vel_std': np.std(velocities),
            'vel_max': np.max(velocities),
            'vel_min': np.min(velocities),
            'vel_median': np.median(velocities)
        }
        
        self.metrics.update(vel_stats)
        return vel_stats
    
    def plot_trajectory_2d(self, save_path: Optional[str] = None):
        """
        Plot 2D trajectory (top-down view).
        
        Args:
            save_path: Path to save the figure
        """
        fig, axes = plt.subplots(1, 3, figsize=(15, 5))
        fig.suptitle('OpenVINS Trajectory Analysis', fontsize=14, fontweight='bold')
        
        est_pos = self.est_trajectory[:, 1:4]
        
        # XY plane (top-down)
        axes[0].plot(est_pos[:, 0], est_pos[:, 1], 'b-', linewidth=1, label='Estimated')
        axes[0].plot(est_pos[0, 0], est_pos[0, 1], 'go', markersize=10, label='Start')
        axes[0].plot(est_pos[-1, 0], est_pos[-1, 1], 'r^', markersize=10, label='End')
        
        if self.aligned_gt is not None:
            gt_pos = self.aligned_gt[:, 1:4]
            axes[0].plot(gt_pos[:, 0], gt_pos[:, 1], 'g--', linewidth=1, 
                        alpha=0.7, label='Ground Truth')
            
        axes[0].set_xlabel('X (m)')
        axes[0].set_ylabel('Y (m)')
        axes[0].set_title('Top-Down View (XY)')
        axes[0].legend()
        axes[0].axis('equal')
        axes[0].grid(True, alpha=0.3)
        
        # XZ plane (side view)
        axes[1].plot(est_pos[:, 0], est_pos[:, 2], 'b-', linewidth=1)
        axes[1].plot(est_pos[0, 0], est_pos[0, 2], 'go', markersize=10)
        axes[1].plot(est_pos[-1, 0], est_pos[-1, 2], 'r^', markersize=10)
        
        if self.aligned_gt is not None:
            axes[1].plot(gt_pos[:, 0], gt_pos[:, 2], 'g--', linewidth=1, alpha=0.7)
            
        axes[1].set_xlabel('X (m)')
        axes[1].set_ylabel('Z (m)')
        axes[1].set_title('Side View (XZ)')
        axes[1].grid(True, alpha=0.3)
        
        # YZ plane (front view)
        axes[2].plot(est_pos[:, 1], est_pos[:, 2], 'b-', linewidth=1)
        axes[2].plot(est_pos[0, 1], est_pos[0, 2], 'go', markersize=10)
        axes[2].plot(est_pos[-1, 1], est_pos[-1, 2], 'r^', markersize=10)
        
        if self.aligned_gt is not None:
            axes[2].plot(gt_pos[:, 1], gt_pos[:, 2], 'g--', linewidth=1, alpha=0.7)
            
        axes[2].set_xlabel('Y (m)')
        axes[2].set_ylabel('Z (m)')
        axes[2].set_title('Front View (YZ)')
        axes[2].grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"Saved trajectory plot to {save_path}")
        plt.show()
    
    def plot_trajectory_3d(self, save_path: Optional[str] = None):
        """
        Plot 3D trajectory.
        
        Args:
            save_path: Path to save the figure
        """
        fig = plt.figure(figsize=(12, 10))
        ax = fig.add_subplot(111, projection='3d')
        
        est_pos = self.est_trajectory[:, 1:4]
        
        # Color by time
        timestamps = self.est_trajectory[:, 0]
        colors = (timestamps - timestamps[0]) / (timestamps[-1] - timestamps[0])
        
        scatter = ax.scatter(est_pos[:, 0], est_pos[:, 1], est_pos[:, 2],
                           c=colors, cmap='viridis', s=2, alpha=0.6)
        
        # Start and end markers
        ax.scatter(*est_pos[0], color='green', s=100, marker='o', label='Start')
        ax.scatter(*est_pos[-1], color='red', s=100, marker='^', label='End')
        
        if self.aligned_gt is not None:
            gt_pos = self.aligned_gt[:, 1:4]
            ax.plot(gt_pos[:, 0], gt_pos[:, 1], gt_pos[:, 2],
                   'g--', linewidth=1, alpha=0.5, label='Ground Truth')
        
        ax.set_xlabel('X (m)')
        ax.set_ylabel('Y (m)')
        ax.set_zlabel('Z (m)')
        ax.set_title('OpenVINS 3D Trajectory', fontsize=14, fontweight='bold')
        ax.legend()
        
        # Add colorbar
        cbar = plt.colorbar(scatter, ax=ax, shrink=0.5, aspect=20)
        cbar.set_label('Time Progress')
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"Saved 3D trajectory plot to {save_path}")
        plt.show()
    
    def plot_errors(self, save_path: Optional[str] = None):
        """
        Plot error analysis (position components over time).
        
        Args:
            save_path: Path to save the figure
        """
        fig, axes = plt.subplots(3, 1, figsize=(12, 10), sharex=True)
        fig.suptitle('OpenVINS Position Components Over Time', fontsize=14, fontweight='bold')
        
        timestamps = self.est_trajectory[:, 0]
        rel_time = timestamps - timestamps[0]
        positions = self.est_trajectory[:, 1:4]
        
        labels = ['X', 'Y', 'Z']
        colors = ['#e74c3c', '#27ae60', '#3498db']
        
        for i, (ax, label, color) in enumerate(zip(axes, labels, colors)):
            ax.plot(rel_time, positions[:, i], color=color, linewidth=1)
            
            if self.aligned_gt is not None:
                gt_rel_time = self.aligned_gt[:, 0] - self.aligned_gt[0, 0]
                ax.plot(gt_rel_time, self.aligned_gt[:, i+1], 
                       color=color, linestyle='--', alpha=0.5, label='GT')
                       
            ax.set_ylabel(f'{label} (m)')
            ax.grid(True, alpha=0.3)
            ax.legend(loc='upper right')
            
        axes[-1].set_xlabel('Time (s)')
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"Saved error plot to {save_path}")
        plt.show()
    
    def plot_velocity_profile(self, save_path: Optional[str] = None):
        """
        Plot velocity profile over time.
        
        Args:
            save_path: Path to save the figure
        """
        positions = self.est_trajectory[:, 1:4]
        timestamps = self.est_trajectory[:, 0]
        
        dt = np.diff(timestamps)
        dt[dt < 1e-6] = 1e-6
        
        dp = np.diff(positions, axis=0)
        velocities = np.linalg.norm(dp, axis=1) / dt
        vel_times = timestamps[:-1] - timestamps[0]
        
        fig, axes = plt.subplots(2, 1, figsize=(12, 8))
        fig.suptitle('OpenVINS Velocity Analysis', fontsize=14, fontweight='bold')
        
        # Velocity over time
        axes[0].plot(vel_times, velocities, 'b-', linewidth=1, alpha=0.7)
        axes[0].axhline(y=np.mean(velocities), color='r', linestyle='--', 
                       label=f'Mean: {np.mean(velocities):.2f} m/s')
        axes[0].fill_between(vel_times, 0, velocities, alpha=0.3)
        axes[0].set_xlabel('Time (s)')
        axes[0].set_ylabel('Velocity (m/s)')
        axes[0].set_title('Velocity Profile')
        axes[0].legend()
        axes[0].grid(True, alpha=0.3)
        
        # Velocity histogram
        axes[1].hist(velocities, bins=50, color='steelblue', edgecolor='black', alpha=0.7)
        axes[1].axvline(x=np.mean(velocities), color='r', linestyle='--', 
                       label=f'Mean: {np.mean(velocities):.2f}')
        axes[1].axvline(x=np.median(velocities), color='g', linestyle='--', 
                       label=f'Median: {np.median(velocities):.2f}')
        axes[1].set_xlabel('Velocity (m/s)')
        axes[1].set_ylabel('Count')
        axes[1].set_title('Velocity Distribution')
        axes[1].legend()
        axes[1].grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"Saved velocity profile to {save_path}")
        plt.show()
    
    def generate_report(self, output_dir: str = '.'):
        """
        Generate a comprehensive evaluation report.
        
        Args:
            output_dir: Directory to save the report and figures
        """
        os.makedirs(output_dir, exist_ok=True)
        
        # Compute all metrics
        print("\n" + "="*60)
        print("OpenVINS Trajectory Evaluation Report")
        print("="*60)
        
        # Trajectory statistics
        stats = self._compute_trajectory_stats()
        print("\nðŸ“Š Trajectory Statistics:")
        print(f"  â€¢ Number of poses: {stats['num_poses']}")
        print(f"  â€¢ Duration: {stats['duration']:.2f} s")
        print(f"  â€¢ Total distance: {stats['total_distance']:.2f} m")
        print(f"  â€¢ Average velocity: {stats['avg_velocity']:.2f} m/s")
        print(f"  â€¢ Bounding box: [{stats['bbox_x']:.2f}, {stats['bbox_y']:.2f}, {stats['bbox_z']:.2f}] m")
        
        # Drift analysis
        drift = self.compute_drift()
        print("\nðŸ“ˆ Drift Analysis:")
        print(f"  â€¢ Total drift: {drift['drift_total']:.4f} m")
        print(f"  â€¢ Drift per meter: {drift['drift_per_meter']:.4f}%")
        print(f"  â€¢ X drift: {drift['drift_x']:.4f} m")
        print(f"  â€¢ Y drift: {drift['drift_y']:.4f} m")
        print(f"  â€¢ Z drift: {drift['drift_z']:.4f} m")
        
        # Velocity analysis
        vel = self.analyze_velocity()
        print("\nðŸš€ Velocity Analysis:")
        print(f"  â€¢ Mean velocity: {vel['vel_mean']:.2f} m/s")
        print(f"  â€¢ Max velocity: {vel['vel_max']:.2f} m/s")
        print(f"  â€¢ Velocity std: {vel['vel_std']:.2f} m/s")
        
        # RPE
        rpe = self.compute_rpe()
        print("\nðŸ“ Relative Pose Error (RPE):")
        print(f"  â€¢ Translation RMSE: {rpe['rpe_trans_rmse']:.4f} m")
        print(f"  â€¢ Rotation RMSE: {rpe['rpe_rot_rmse']:.4f} deg")
        
        # ATE (if ground truth available)
        if self.gt_trajectory is not None:
            ate = self.compute_ate()
            print("\nðŸŽ¯ Absolute Trajectory Error (ATE):")
            print(f"  â€¢ RMSE: {ate['ate_rmse']:.4f} m")
            print(f"  â€¢ Mean: {ate['ate_mean']:.4f} m")
            print(f"  â€¢ Max: {ate['ate_max']:.4f} m")
        
        print("\n" + "="*60)
        
        # Save metrics to YAML
        metrics_file = os.path.join(output_dir, 'evaluation_metrics.yaml')
        with open(metrics_file, 'w') as f:
            yaml.dump(self.metrics, f, default_flow_style=False)
        print(f"\nðŸ’¾ Metrics saved to {metrics_file}")
        
        # Generate plots
        print("\nðŸ“Š Generating plots...")
        self.plot_trajectory_2d(os.path.join(output_dir, 'trajectory_2d.png'))
        self.plot_trajectory_3d(os.path.join(output_dir, 'trajectory_3d.png'))
        self.plot_errors(os.path.join(output_dir, 'position_components.png'))
        self.plot_velocity_profile(os.path.join(output_dir, 'velocity_profile.png'))
        
        print("\nâœ… Evaluation complete!")
        return self.metrics


def record_trajectory_from_ros(output_file: str, topic: str = '/ov_msckf/odomimu',
                               duration: float = 60.0):
    """
    Record trajectory from ROS2 topic to TUM format file.
    
    Args:
        output_file: Output file path
        topic: ROS2 odometry topic
        duration: Recording duration in seconds
    """
    try:
        import rclpy
        from rclpy.node import Node
        from nav_msgs.msg import Odometry
        
        class TrajectoryRecorder(Node):
            def __init__(self):
                super().__init__('trajectory_recorder')
                self.poses = []
                self.subscription = self.create_subscription(
                    Odometry, topic, self.odom_callback, 10)
                print(f"Recording from {topic} for {duration}s...")
                
            def odom_callback(self, msg):
                t = msg.header.stamp.sec + msg.header.stamp.nanosec * 1e-9
                p = msg.pose.pose.position
                q = msg.pose.pose.orientation
                self.poses.append([t, p.x, p.y, p.z, q.x, q.y, q.z, q.w])
                
            def save(self, filepath):
                if self.poses:
                    np.savetxt(filepath, np.array(self.poses), 
                              fmt='%.9f %.9f %.9f %.9f %.9f %.9f %.9f %.9f')
                    print(f"Saved {len(self.poses)} poses to {filepath}")
                    
        rclpy.init()
        recorder = TrajectoryRecorder()
        
        import time
        start = time.time()
        while time.time() - start < duration:
            rclpy.spin_once(recorder, timeout_sec=0.1)
            
        recorder.save(output_file)
        recorder.destroy_node()
        rclpy.shutdown()
        
    except ImportError:
        print("ROS2 not available. Use --input to provide a trajectory file.")
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description='OpenVINS Trajectory Evaluation Tool',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Evaluate from file
  python evaluate_openvins.py --input trajectory.txt --output results/

  # Record and evaluate
  python evaluate_openvins.py --record --duration 60 --output results/

  # Compare with ground truth
  python evaluate_openvins.py --input est.txt --groundtruth gt.txt --output results/
        """
    )
    
    parser.add_argument('--input', '-i', type=str, 
                       help='Input trajectory file (TUM format)')
    parser.add_argument('--groundtruth', '-g', type=str,
                       help='Ground truth trajectory file (TUM format)')
    parser.add_argument('--output', '-o', type=str, default='./evaluation_results',
                       help='Output directory for results')
    parser.add_argument('--record', action='store_true',
                       help='Record trajectory from ROS2 topic')
    parser.add_argument('--topic', type=str, default='/ov_msckf/odomimu',
                       help='ROS2 topic for recording')
    parser.add_argument('--duration', type=float, default=60.0,
                       help='Recording duration in seconds')
    
    args = parser.parse_args()
    
    # Create output directory
    os.makedirs(args.output, exist_ok=True)
    
    # Determine input file
    if args.record:
        input_file = os.path.join(args.output, 'recorded_trajectory.txt')
        record_trajectory_from_ros(input_file, args.topic, args.duration)
    elif args.input:
        input_file = args.input
    else:
        # Try to find a trajectory file in common locations
        common_paths = [
            'trajectory.txt',
            'estimated_trajectory.txt',
            'ov_estimate.txt',
            '/tmp/ov_estimate.txt'
        ]
        input_file = None
        for path in common_paths:
            if os.path.exists(path):
                input_file = path
                break
                
        if input_file is None:
            print("Error: No trajectory file found. Use --input or --record")
            sys.exit(1)
    
    # Run evaluation
    try:
        evaluator = TrajectoryEvaluator(input_file, args.groundtruth)
        evaluator.generate_report(args.output)
    except Exception as e:
        print(f"Error during evaluation: {e}")
        sys.exit(1)


if __name__ == '__main__':
    main()

